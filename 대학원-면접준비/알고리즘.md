## Bubble Sort
- 첫번째 원소부터 시작해 다음 원소와 비교하여 조건에 맞지 않다면 Swap
- 다음 Loop에서는 마지막 원소는 제외하고 연산을 수행한다.

#### 장점
- 직관적이며 구현하기 쉽다.
- Stable Sort이다.
- 추가적인 메모리가 소모되지 않는다.

#### 단점
- 시간복잡도가 O(N^2)로 비효율적이다.
- Swap 연산이 많이 일어난다.

## Selected Sort
- 원소가 Swap될 위치를 정한뒤 실제로 들어갈 원소를 선택한다.
- 다음 위치에서도 동일한 연산을 수행한다.

#### 장점
- 직관적이며 구현하기 쉽다.
- 추가적인 메모리가 필요하지 않는다.
- Bubble Sort보단 Swap이 덜 일어난다.

#### 단점
- Unstable Sort이다.
- 시간복잡도가 O(n^2)으로 비효율 적이다.

## Insert Sort
- 두번쨰 원소부터 시작하여 이전의 원소들중 조건에 맞는 자리에 삽입한다.

#### 장점
- 최선의 경우 O(n)으로 효율적이다.
- Stable Sort이다.
- 추가적인 메모리가 소모되지 않는다.

#### 단점
- 최악, 평균 의 경우 O(n^2)로 여전히 비효율 적이다.

## Quick Sort
- Pivot을 기준으로 비교하여 왼쪽 오른쪽으로 원소를 분리한다.
- 왼쪽 오른쪽으로 분리된 원소들에 대해서 새로운 Pivot을 기준으로 배열을 분리한다.
- 각원소가 1개 남을때까지 반복한다.

#### 장점
- 최선, 평균 시간복잡도가 O(nlog2n)이 소모된다.
- 제자리 정렬로 추가적인 메모리 소모가 없다.

#### 단점
- 최악의 경우 O(n^2)이 소모된다.
- 이미 정렬된 경우에도 O(nlog2n)으로 비효율적이다.
- Unstable Sort이다.

## Merge Sort
- 배열을 2개로 쪼갠다.
- 이후 쪼개진 배열또한 2개로 쪼갠 후 배열이 1개가 남을 때까지 쪼갠다.
- 원소를 크기를 고려하여 병합한다.

#### 장점
- 최선, 평균, 최악 시간복잡도가 O(nlog2n)이다.
- Stable Sort이다.

#### 단점
- 추가적인 메모리가 소모된다.

## Heap Sort
- 이진트리를 기본으로 하는 Heap 기반의 Sort이다.
- 가장 크거나 작은 원소가 트리의 Root에 위치하도록 한다.
- 이후 Root의 원소를 제거하여 정렬할 수 있다.

#### 장점
- 최선, 평균, 최악 시간 복잡도가 O(nlog2n)이다.
- 배열의 특정 개수 만큼만 정렬을 원할 때 효율적이다.

#### 단점
- Unstable Sort이다.
- 같은 O(nlog2n)이라도 시간이 더 소모된다.

## Radix Sort
- 첫번쨰 자리수 기준 정렬 후 두번째 자리수 기준 정렬 후 마지막 자리수 기준으로 정렬한다.

#### 장점
- O(n*자리수)시간이 소모된다.
- Stable Sort이다.

#### 단점
- 자리수가 존재 해야하며 같은 자리수를 갖는 원소끼리만 비교 가능하다.
- 추가적인 메모리가 소모된다.

## Counting Sort
- 원소의 최소값 부터 최대값까지 배열을 만들어 해당 크기의 원소가 몇개씩 있나 체크한다.

#### 장점
- 최선, 평균, 최악 시간복잡도가 O(n)이다.

#### 단점
- 원소의 최소값부터 최대값까지에 해당하는 배열을 만들어야 하기 때문에 메모리가 많이 소모된다.
- Unstable Sort이다.


## 정렬 알고리즘 비교

알고리즘 | 최선 | 평균 | 최악 | 안정성 | 메모리
-- | -- | -- | -- | -- | --
Bubble | n^2 | n^2 | n^2 | O | X
Selection | n^2 | n^2 | n^2 | X | X
Insert | n | n^2 | n^2 | O | X
Quick | nlog2n | nlog2n | n^2 | X | X
Merge | nlog2n | nlog2n | nlog2n | O | O
Heap | nlog2n | nlog2n | nlog2n | X | X
Radix | n*자리수 | n*자리수 | n*자리수 | O | O
Count | n | n | n | X | O

## Binary Search
- 탐색하는 방법 중 하나로 처음부터 탐색하는 것보다 빠르다.
- Left와 Right를 설정하고 중간점 Mid를 알아낸다. 
- Mid Index 원소와 비교하여 Left나 Right를 변경하며 타겟 원소를 찾는다.
- 이때 O(log2n)이 소모 된다.

## DFS & BFS

#### DFS
- 다음 브랜치로 넘어가기전 해당 브랜치의 모든 원소를 탐색하는 알고리즘이다.
- 해가 깊게 있을것이라 예상될때 사용된다.
- 찾은 경로가 최단경로라고 확신할 수 없다.

## Dynamic Programming
- 같은 차수에 있는 브랜치를 먼저 탐색하는 알고리즘이다.
- 해가 얕은 곳에 있을것이라 예상될때 사용된다.
- 찾은 경로가 최단 경로이다. 따라서 최단 경로를 찾을때 자주 사용한다.

## 다익스트라
- 특정 노드에서 최소비용으로 다른 노드로 갈때 사용하는 알고리즘이다.
- 시작 노드에서 다른 노드까지 가는 비용을 저장한다.
- 이후 탐색하지 않은 노드로 가서 다른 노드로 가는 방법을 탐색한후 이전에 찾은 비용보다 작으면 갱신한다.
- 모든 노트를 방문하여 최소비용 거리를 찾는다.