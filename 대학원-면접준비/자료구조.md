## Array의 가장 큰 특징과 그로 인해 발생하는 장점과 단점
- Array는 데이터를 순차적으로 저장한다.
- 그렇기 때문에 Index로 접근이 가능해서 검색 시간이 O(1)이 소모 된다.
- 그러나 순차적인 저장을 유지하기 위해 삽입 삭제시 모든 데이터를 Shift해야 하기 때문에 O(n)시간이 걸린다.


## Array 적용시 좋은 데이터 예시
- 주식 차트가 있다. 
- 주식 차트는 삽입 삭제 되는 데이터가 아니며 검색만 하는 데이터 이기 때문이다.
- 또한 순서가 중요한 정보 이므로 Array는 순서를 보장해 주는 자료구조 이다.

## Stack과 Queue
- 자료간 앞뒤 관계가 1:1로 연결 되어 있는 선형 자료 구조이다.

#### Stack
- stack은 후입선출 구조로 나중에 들어간 데이터가 먼저 나오는 구조이다.
- 함수의 콜스택, 실행취소, 뒤로가기 기능 등 에서 사용된다.
- Pop 연산으로 데이터를 맨 뒤에서 빼고, Push 연산으로 데이터를 맨 뒤에 넣는다.

#### Queue
- Queue는 선입 선출 구조로 먼저 들어간 데이터가 먼저 나온다.
- 맨앞을 Front라고 하며, 맨뒤를 Back이나 Rear라고 한다.
- 처리 프로세스의 개수 제한 떄문에 Job이 몰릴때 Job을 순차적으로 처리 할때 사용한다.

## Tree와 Heap
- 데이터간 1:다 관계를 갖는 비선형 자료 구조 이다.

#### Tree
- 그래프의 일종으로 방향성이 있고, Cycle을 허용하지 않는 그래프 자료 구조이다.
- 최상단 Root 노드로 부터 데이터가 연결되어 있는 계층 구조 이다.

#### Heap
- Tree의 일종으로 특별한 순서를 가지고 있는 자료 구조이다.
- 예를 들어 Max Heap은 가장 큰 값이 Root 노드이며 자식 노드는 항상 부모 노드보다 작게 유지 된다.
- Complete Binary Tree이다.

## Tree와 Graph
- 데이터간 1:多 구조를 갖는 비선형적 자료 구조이다.

#### Graph
- 노드와 노드를 연결하는 간선으로 이루어진 자료구조 이다.

#### Tree
- Graph의 일종이다.
- 순환을 허용하지 않는 비순환 그래프이며 방향을 가지는 그래프이다.
- 계층형 구조 이며, 모든 노드는 Root 노드에 연결 되어 있다.
- 노드와 노드간 경로는 유일하다.

## Priority Queue
- Queue는 먼저 입력된 값이 먼저 나오는 선입선출 구조이다.
- 그러나 우선순위 큐는 각 데이터에 우선순위가 매겨져 있어 입력 순서와 관계 없이 우선순위가 높은 데이터가 먼저 나오는 구조이다.

## Array VS Linked List
- Array는 데이터가 순차적으로 저장 된다, Linked List는 순차적으로 저장되지 않으며 각 데이터가 다음 저장된 데이터의 주소값을 가지고 있다.
- 검색시 Array는 Index로 접근 가능하 므로 O(1)이 소모 되나 Linked List는 데이터를 순차적으로 따라가며 검색 해야 하므로 O(n)이 소모된다.
- 삽입&삭제 시 Array는 모든 데이터를 Shift 해야 하므로 O(n)이 소모되나, Linked List는 삽입&삭제에 관련된 데이터의 주소값만 바꿔주면 되므로 O(1)가 소모 된다.

## Hash Table이란?
- key값을 Hash Function에 통과시켜 Index값(Hash)로 만든 후 이 Hash를 기반으로 Bucket에 저장하는 자료 구조이다.
- Hash값이 Bucket에 고루 분포 될 수 있도록 설계 하는 것이 Hash Table의 성능을 좌지우지 한다.

## Hash Table과 시간 복잡도
- Hash 테이블은 Key값을 Hash 함수를 통해 Hash 값으로 만든후 그 Hash 값을 Index로 사용하여 Bucket에 저장하는 자료 구조 이다.
- 검색시 Hash 함수를 통해 만들어진 Hash가 Index로 사용 되므로 O(1)이 소모 된다.

## Hash Table의 collision처리
- Key값이 Hash 함수에 의해 같은 Hash 값이 나와 Index가 겹치는 경우 발생한다.
- 이때를 충돌 이라 하며 Chaining, Open Adrress, Resize 3가지 방법이 있다.

#### Chaining
- 충돌된 데이터 끼리 연결하는 방법이다.
- 주로 Linked List나 Red Black Tree를 사용하며 데이터가 다음 데이터의 주소값을 가지고 있는 구조 이다.
- 최악의 경우 전체 데이터에 충돌이 발생하여 검색시 O(n)이 소모될 수도 있다.

#### Open Address
- 충돌이 발생한 데이터에 대해 Index값을 바꿔주는 것이다.
- 충돌이 발생한 Index 에 특정한 상수값을 더해 주며 비어 있는 Bucket을 찾는다.
- 또는 1번째 는 1^2, 2번째는 2^2 같이 증가 시키며 다음 Bucket을 찾을 수도 있다.
- 다른 방법으로 충돌이 발생한 경우 한번더 Hash 함수를 통해 hash 값을 뽑을 수도 있다.

#### Resize
- 충돌이 발생한 경우 Bucket의 개수를 늘리는 방버이다.

## Binary Tree
- Tree의 일종으로 노드의 자식수가 2개 이하인 Tree이다.

## Binary Search Tree
- 노드가 특정 순서를 가진 트리 이다.
- 효율적인 탐색 능력이 있으며 시간 검색시 Tree의 Depth의 영향을 받기 때문에 시간 복잡도가 O(logn)이다.
- 탐색 속도는 트리의 높이와 비례하다. 이때 트리의 높이를 H라고 하면 전체 노드 개수 N과의 관계는 N = H^2 - 1이다. 이식을 H에 대해서 풀어보면 H = Log2N+1이라 표현 가능 하고 빅오에 대해서 O(Log2N)이 걸린다.
- 그러나 한쪽으로 치우쳐진 트리인 경우 O(n)의 시간이 걸릴 수 있다.
- 이러한 Worst Case를 막기 위한 방법으로 AVL Tree가 있다.

## AVL Tree?
- Binary Search Tree는 트리가 한쪽으로 치우쳐진 경우 O(n)의 시간이 걸릴 수 있다
- 이러한 한계점을 보완하기 위한 균형 잡힌 이진 트리이다.
- AVL 트리는 좌/우로 균형잡힌 데이터 형태를 유지하기 위해 추가적인 연산을 수행한다.

## Red-Black Tree
- RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어 졌다.
- Binary Search Tree는 한쪽으로 치우쳐진 형태가 발생할 수 있으나 Red Balck Tree는 이것을 방비 했다.


## DFS VS BFS  

#### DFS
- 루트 노드에서 다음 branch로 넘어가기전 해당 분기를 먼저 탐색 하는 방법(자식을 우선적으로 탐색 하는 방법)
- 스택 또는 재귀를 통해서 구현 가능
- 저장 공간의 필요성이 적다, 찾아야 하는 노드가 깊은 단계에 있을 수록 그 해를 찾기 유리하다.
- 찾은 해가 최단 경로라는 보장이 없다.

#### BFS
- 루트 노드에서 인접한 노트부터 탐색하는 방법(형제 노드를 우선으로 탐색하는 방법)
- Queue를 통해서 구현 가능하다.
- 최단거리를 구하는 문제에서 사용한다.
- DFS보다 빠르다. DFS 같은 경우 모든 노드를 방문하기 때문이다.
- 노드수가 적고 깊이가 얕은 노드에 해가 존재 할 때 유리 하다.
- 탐색할 노드들을 저장해야 하기 때문에 노드가 많을 수록 더 큰 저장공간이 필요하다.

## 다익스트라란?
- 최단 경로 탐색 알고리즘 입니다.
- 시작 노드를 방문하여 갈수 있는 모든 노드의 경로를 파악합니다.
- 이후에 방문하지 않은 노드에서 갈 수 있는 노드를 조사하고 이전에 갈 수 있던 경로보다 짧다면 최단경로를 갱신합니다
- 이와 같은 행위를 반복하여 시작 노드에서 모든 노드로 가는 최단 경로를 탐색할 수 있습니다.